<?php
 namespace Zend\Http\Client\Adapter; use Zend\Http\Client\Adapter as HttpAdapter, Zend\Http\Client\Adapter\Exception as AdapterException, Zend\Http\Response; class Socket implements HttpAdapter, Stream { protected $socket = null; protected $connected_to = array(null, null); protected $out_stream = null; protected $config = array( 'persistent' => false, 'ssltransport' => 'ssl', 'sslcert' => null, 'sslpassphrase' => null, 'sslusecontext' => false ); protected $method = null; protected $_context = null; public function __construct() { } public function setConfig($config = array()) { if ($config instanceof \Zend\Config\Config) { $config = $config->toArray(); } elseif (! is_array($config)) { throw new AdapterException\InvalidArgumentException( 'Array or Zend_Config object expected, got ' . gettype($config) ); } foreach ($config as $k => $v) { $this->config[strtolower($k)] = $v; } } public function getConfig() { return $this->config; } public function setStreamContext($context) { if (is_resource($context) && get_resource_type($context) == 'stream-context') { $this->_context = $context; } elseif (is_array($context)) { $this->_context = stream_context_create($context); } else { throw new AdapterException\InvalidArgumentException( "Expecting either a stream context resource or array, got " . gettype($context) ); } return $this; } public function getStreamContext() { if (! $this->_context) { $this->_context = stream_context_create(); } return $this->_context; } public function connect($host, $port = 80, $secure = false) { $host = ($secure ? $this->config['ssltransport'] : 'tcp') . '://' . $host; if (($this->connected_to[0] != $host || $this->connected_to[1] != $port)) { if (is_resource($this->socket)) $this->close(); } if (! is_resource($this->socket) || ! $this->config['keepalive']) { $context = $this->getStreamContext(); if ($secure || $this->config['sslusecontext']) { if ($this->config['sslcert'] !== null) { if (! stream_context_set_option($context, 'ssl', 'local_cert', $this->config['sslcert'])) { throw new AdapterException\RuntimeException('Unable to set sslcert option'); } } if ($this->config['sslpassphrase'] !== null) { if (! stream_context_set_option($context, 'ssl', 'passphrase', $this->config['sslpassphrase'])) { throw new AdapterException\RuntimeException('Unable to set sslpassphrase option'); } } } $flags = STREAM_CLIENT_CONNECT; if ($this->config['persistent']) $flags |= STREAM_CLIENT_PERSISTENT; $this->socket = @stream_socket_client($host . ':' . $port, $errno, $errstr, (int) $this->config['timeout'], $flags, $context); if (! $this->socket) { $this->close(); throw new AdapterException\RuntimeException( 'Unable to Connect to ' . $host . ':' . $port . '. Error #' . $errno . ': ' . $errstr); } if (! stream_set_timeout($this->socket, (int) $this->config['timeout'])) { throw new AdapterException\RuntimeException('Unable to set the connection timeout'); } $this->connected_to = array($host, $port); } } public function write($method, $uri, $http_ver = '1.1', $headers = array(), $body = '') { if (! $this->socket) { throw new AdapterException\RuntimeException('Trying to write but we are not connected'); } $host = $uri->getHost(); $host = (strtolower($uri->getScheme()) == 'https' ? $this->config['ssltransport'] : 'tcp') . '://' . $host; if ($this->connected_to[0] != $host || $this->connected_to[1] != $uri->getPort()) { throw new AdapterException\RuntimeException('Trying to write but we are connected to the wrong host'); } $this->method = $method; $path = $uri->getPath(); if ($uri->getQuery()) $path .= '?' . $uri->getQuery(); $request = "{$method} {$path} HTTP/{$http_ver}\r\n"; foreach ($headers as $k => $v) { if (is_string($k)) $v = ucfirst($k) . ": $v"; $request .= "$v\r\n"; } if(is_resource($body)) { $request .= "\r\n"; } else { $request .= "\r\n" . $body; } if (! @fwrite($this->socket, $request)) { throw new AdapterException\RuntimeException('Error writing request to server'); } if(is_resource($body)) { if(stream_copy_to_stream($body, $this->socket) == 0) { throw new AdapterException\RuntimeException('Error writing request to server'); } } return $request; } public function read() { $response = ''; $gotStatus = false; $stream = !empty($this->config['stream']); while (($line = @fgets($this->socket)) !== false) { $gotStatus = $gotStatus || (strpos($line, 'HTTP') !== false); if ($gotStatus) { $response .= $line; if (rtrim($line) === '') break; } } $this->_checkSocketReadTimeout(); $statusCode = Response::extractCode($response); if ($statusCode == 100 || $statusCode == 101) return $this->read(); $headers = Response::extractHeaders($response); if ($statusCode == 304 || $statusCode == 204 || $this->method == \Zend\Http\Client::HEAD) { if (isset($headers['connection']) && $headers['connection'] == 'close') { $this->close(); } return $response; } if (isset($headers['transfer-encoding'])) { if (strtolower($headers['transfer-encoding']) == 'chunked') { do { $line = @fgets($this->socket); $this->_checkSocketReadTimeout(); $chunk = $line; $chunksize = trim($line); if (! ctype_xdigit($chunksize)) { $this->close(); throw new AdapterException\RuntimeException('Invalid chunk size "' . $chunksize . '" unable to read chunked body'); } $chunksize = hexdec($chunksize); $read_to = ftell($this->socket) + $chunksize; do { $current_pos = ftell($this->socket); if ($current_pos >= $read_to) break; if($this->out_stream) { if(stream_copy_to_stream($this->socket, $this->out_stream, $read_to - $current_pos) == 0) { $this->_checkSocketReadTimeout(); break; } } else { $line = @fread($this->socket, $read_to - $current_pos); if ($line === false || strlen($line) === 0) { $this->_checkSocketReadTimeout(); break; } $chunk .= $line; } } while (! feof($this->socket)); $chunk .= @fgets($this->socket); $this->_checkSocketReadTimeout(); if(!$this->out_stream) { $response .= $chunk; } } while ($chunksize > 0); } else { $this->close(); throw new AdapterException\RuntimeException('Cannot handle "' . $headers['transfer-encoding'] . '" transfer encoding'); } if ($this->out_stream) { $response = str_ireplace("Transfer-Encoding: chunked\r\n", '', $response); } } elseif (isset($headers['content-length'])) { if (is_array($headers['content-length'])) { $contentLength = $headers['content-length'][count($headers['content-length']) - 1]; } else { $contentLength = $headers['content-length']; } $current_pos = ftell($this->socket); $chunk = ''; for ($read_to = $current_pos + $contentLength; $read_to > $current_pos; $current_pos = ftell($this->socket)) { if($this->out_stream) { if(@stream_copy_to_stream($this->socket, $this->out_stream, $read_to - $current_pos) == 0) { $this->_checkSocketReadTimeout(); break; } } else { $chunk = @fread($this->socket, $read_to - $current_pos); if ($chunk === false || strlen($chunk) === 0) { $this->_checkSocketReadTimeout(); break; } $response .= $chunk; } if (feof($this->socket)) break; } } else { do { if($this->out_stream) { if(@stream_copy_to_stream($this->socket, $this->out_stream) == 0) { $this->_checkSocketReadTimeout(); break; } } else { $buff = @fread($this->socket, 8192); if ($buff === false || strlen($buff) === 0) { $this->_checkSocketReadTimeout(); break; } else { $response .= $buff; } } } while (feof($this->socket) === false); $this->close(); } if (isset($headers['connection']) && $headers['connection'] == 'close') { $this->close(); } return $response; } public function close() { if (is_resource($this->socket)) @fclose($this->socket); $this->socket = null; $this->connected_to = array(null, null); } protected function _checkSocketReadTimeout() { if ($this->socket) { $info = stream_get_meta_data($this->socket); $timedout = $info['timed_out']; if ($timedout) { $this->close(); throw new AdapterException\TimeoutException( "Read timed out after {$this->config['timeout']} seconds", AdapterException\TimeoutException::READ_TIMEOUT ); } } } public function setOutputStream($stream) { $this->out_stream = $stream; return $this; } public function __destruct() { if (! $this->config['persistent']) { if ($this->socket) $this->close(); } } } 