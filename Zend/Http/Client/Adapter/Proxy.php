<?php
 namespace Zend\Http\Client\Adapter; use Zend\Http\Client, Zend\Http\Client\Adapter\Exception as AdapterException; class Proxy extends Socket { protected $config = array( 'ssltransport' => 'ssl', 'sslcert' => null, 'sslpassphrase' => null, 'sslusecontext' => false, 'proxy_host' => '', 'proxy_port' => 8080, 'proxy_user' => '', 'proxy_pass' => '', 'proxy_auth' => Client::AUTH_BASIC, 'persistent' => false ); protected $negotiated = false; public function connect($host, $port = 80, $secure = false) { if (! $this->config['proxy_host']) { return parent::connect($host, $port, $secure); } if ($secure) { $this->config['sslusecontext'] = true; } return parent::connect( $this->config['proxy_host'], $this->config['proxy_port'], false ); } public function write($method, $uri, $http_ver = '1.1', $headers = array(), $body = '') { if (! $this->config['proxy_host']) return parent::write($method, $uri, $http_ver, $headers, $body); if (! $this->socket) { throw new AdapterException\RuntimeException("Trying to write but we are not connected"); } $host = $this->config['proxy_host']; $port = $this->config['proxy_port']; if ($this->connected_to[0] != "tcp://$host" || $this->connected_to[1] != $port) { throw new AdapterException\RuntimeException("Trying to write but we are connected to the wrong proxy server"); } if ($this->config['proxy_user'] && ! isset($headers['proxy-authorization'])) { $headers['proxy-authorization'] = Client::encodeAuthHeader( $this->config['proxy_user'], $this->config['proxy_pass'], $this->config['proxy_auth'] ); } if ($uri->getScheme() == 'https' && (! $this->negotiated)) { $this->connectHandshake($uri->getHost(), $uri->getPort(), $http_ver, $headers); $this->negotiated = true; } $this->method = $method; if ($this->negotiated) { $path = $uri->getPath(); if ($uri->getQuery()) { $path .= '?' . $uri->getQuery(); } $request = "$method $path HTTP/$http_ver\r\n"; } else { $request = "$method $uri HTTP/$http_ver\r\n"; } foreach ($headers as $k => $v) { if (is_string($k)) $v = "$k: $v"; $request .= "$v\r\n"; } if(is_resource($body)) { $request .= "\r\n"; } else { $request .= "\r\n" . $body; } if (! @fwrite($this->socket, $request)) { throw new AdapterException\RuntimeException("Error writing request to proxy server"); } if (is_resource($body)) { if(stream_copy_to_stream($body, $this->socket) == 0) { throw new AdapterException\RuntimeException('Error writing request to server'); } } return $request; } protected function connectHandshake($host, $port = 443, $http_ver = '1.1', array &$headers = array()) { $request = "CONNECT $host:$port HTTP/$http_ver\r\n" . "Host: " . $this->config['proxy_host'] . "\r\n"; if (isset($this->config['useragent'])) { $request .= "User-agent: " . $this->config['useragent'] . "\r\n"; } if (isset($headers['proxy-authorization'])) { $request .= "Proxy-authorization: " . $headers['proxy-authorization'] . "\r\n"; unset($headers['proxy-authorization']); } $request .= "\r\n"; if (! @fwrite($this->socket, $request)) { throw new AdapterException\RuntimeException("Error writing request to proxy server"); } $response = ''; $gotStatus = false; while ($line = @fgets($this->socket)) { $gotStatus = $gotStatus || (strpos($line, 'HTTP') !== false); if ($gotStatus) { $response .= $line; if (!rtrim($line)) break; } } if (\Zend\Http\Response::extractCode($response) != 200) { throw new AdapterException\RuntimeException("Unable to connect to HTTPS proxy. Server response: " . $response); } $modes = array( STREAM_CRYPTO_METHOD_TLS_CLIENT, STREAM_CRYPTO_METHOD_SSLv3_CLIENT, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, STREAM_CRYPTO_METHOD_SSLv2_CLIENT ); $success = false; foreach($modes as $mode) { $success = stream_socket_enable_crypto($this->socket, true, $mode); if ($success) break; } if (! $success) { throw new AdapterException\RuntimeException("Unable to connect to" . " HTTPS server through proxy: could not negotiate secure connection."); } } public function close() { parent::close(); $this->negotiated = false; } public function __destruct() { if ($this->socket) $this->close(); } } 