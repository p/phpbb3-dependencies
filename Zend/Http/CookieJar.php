<?php
 namespace Zend\Http; use Countable, IteratorAggregate, Zend\Uri; class CookieJar implements Countable, IteratorAggregate { const COOKIE_OBJECT = 0; const COOKIE_STRING_ARRAY = 1; const COOKIE_STRING_CONCAT = 2; protected $cookies = array(); protected $_rawCookies = array(); public function __construct() { } public function addCookie($cookie, $ref_uri = null) { if (is_string($cookie)) { $cookie = Cookie::fromString($cookie, $ref_uri); } if ($cookie instanceof Cookie) { $domain = $cookie->getDomain(); $path = $cookie->getPath(); if (!isset($this->cookies[$domain])) { $this->cookies[$domain] = array(); } if (!isset($this->cookies[$domain][$path])) { $this->cookies[$domain][$path] = array(); } $this->cookies[$domain][$path][$cookie->getName()] = $cookie; $this->_rawCookies[] = $cookie; } else { throw new Exception\InvalidArgumentException('Supplient argument is not a valid cookie string or object'); } } public function addCookiesFromResponse($response, $ref_uri) { if (!$response instanceof Response) { throw new Exception\InvalidArgumentException('$response is expected to be a Response object, ' . gettype($response) . ' was passed'); } $cookie_hdrs = $response->getHeader('Set-Cookie'); if (is_array($cookie_hdrs)) { foreach ($cookie_hdrs as $cookie) { $this->addCookie($cookie, $ref_uri); } } elseif (is_string($cookie_hdrs)) { $this->addCookie($cookie_hdrs, $ref_uri); } } public function getAllCookies($ret_as = self::COOKIE_OBJECT) { $cookies = $this->_flattenCookiesArray($this->cookies, $ret_as); return $cookies; } public function getMatchingCookies($uri, $matchSessionCookies = true, $ret_as = self::COOKIE_OBJECT, $now = null) { if (is_string($uri)) { $uri = Uri\UriFactory::factory($uri, 'http'); } if (!$uri instanceof Uri\Uri) { throw new Exception\InvalidArgumentException("Invalid URI string or object passed"); } $host = $uri->getHost(); if (empty($host)) { throw new Exception\InvalidArgumentException('Invalid URI specified; does not contain a host'); } $cookies = $this->_matchDomain($host); $cookies = $this->_matchPath($cookies, $uri->getPath()); $cookies = $this->_flattenCookiesArray($cookies, self::COOKIE_OBJECT); $ret = array(); foreach ($cookies as $cookie) if ($cookie->match($uri, $matchSessionCookies, $now)) $ret[] = $cookie; $ret = $this->_flattenCookiesArray($ret, $ret_as); return $ret; } public function getCookie($uri, $cookie_name, $ret_as = self::COOKIE_OBJECT) { if (is_string($uri)) { $uri = Uri\UriFactory::factory($uri, 'http'); } if (!$uri instanceof Uri\Uri) { throw new Exception\InvalidArgumentException('Invalid URI specified'); } $host = $uri->getHost(); if (empty($host)) { throw new Exception\InvalidArgumentException('Invalid URI specified; host missing'); } $path = $uri->getPath(); $path = substr($path, 0, strrpos($path, '/')); if (! $path) $path = '/'; if (isset($this->cookies[$uri->getHost()][$path][$cookie_name])) { $cookie = $this->cookies[$uri->getHost()][$path][$cookie_name]; switch ($ret_as) { case self::COOKIE_OBJECT: return $cookie; break; case self::COOKIE_STRING_ARRAY: case self::COOKIE_STRING_CONCAT: return $cookie->__toString(); break; default: throw new Exception\InvalidArgumentException("Invalid value passed for \$ret_as: {$ret_as}"); break; } } else { return false; } } protected function _flattenCookiesArray($ptr, $ret_as = self::COOKIE_OBJECT) { if (is_array($ptr)) { $ret = ($ret_as == self::COOKIE_STRING_CONCAT ? '' : array()); foreach ($ptr as $item) { if ($ret_as == self::COOKIE_STRING_CONCAT) { $ret .= $this->_flattenCookiesArray($item, $ret_as); } else { $ret = array_merge($ret, $this->_flattenCookiesArray($item, $ret_as)); } } return $ret; } elseif ($ptr instanceof Cookie) { switch ($ret_as) { case self::COOKIE_STRING_ARRAY: return array($ptr->__toString()); break; case self::COOKIE_STRING_CONCAT: return $ptr->__toString(); break; case self::COOKIE_OBJECT: default: return array($ptr); break; } } return null; } protected function _matchDomain($domain) { $ret = array(); foreach (array_keys($this->cookies) as $cdom) { if (Cookie::matchCookieDomain($cdom, $domain)) { $ret[$cdom] = $this->cookies[$cdom]; } } return $ret; } protected function _matchPath($domains, $path) { $ret = array(); foreach ($domains as $dom => $paths_array) { foreach (array_keys($paths_array) as $cpath) { if (Cookie::matchCookiePath($cpath, $path)) { if (! isset($ret[$dom])) { $ret[$dom] = array(); } $ret[$dom][$cpath] = $paths_array[$cpath]; } } } return $ret; } public static function fromResponse(Response $response, $ref_uri) { $jar = new self(); $jar->addCookiesFromResponse($response, $ref_uri); return $jar; } public function count() { return count($this->_rawCookies); } public function getIterator() { return new \ArrayIterator($this->_rawCookies); } public function isEmpty() { return count($this) == 0; } public function reset() { $this->cookies = $this->_rawCookies = array(); return $this; } } 