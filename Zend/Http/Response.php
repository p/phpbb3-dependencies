<?php
 namespace Zend\Http; class Response { protected static $messages = array( 100 => 'Continue', 101 => 'Switching Protocols', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Long', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Timeout', 505 => 'HTTP Version Not Supported', 509 => 'Bandwidth Limit Exceeded' ); protected $version; protected $code; protected $message; protected $headers = array(); protected $body; public function __construct($code, $headers, $body = null, $version = '1.1', $message = null) { if (self::responseCodeAsText($code) === null) { throw new Exception\InvalidArgumentException("{$code} is not a valid HTTP response code"); } $this->code = $code; if (! is_array($headers)) { throw new Exception\InvalidArgumentException('No valid headers were passed'); } foreach ($headers as $name => $value) { if (is_int($name)) list($name, $value) = explode(": ", $value, 1); $this->headers[ucwords(strtolower($name))] = $value; } $this->body = $body; if (! preg_match('|^\d\.\d$|', $version)) { throw new Exception\InvalidArgumentException("Invalid HTTP response version: $version"); } $this->version = $version; if (is_string($message)) { $this->message = $message; } else { $this->message = self::responseCodeAsText($code); } } public function isError() { $restype = floor($this->code / 100); if ($restype == 4 || $restype == 5) { return true; } return false; } public function isSuccessful() { $restype = floor($this->code / 100); if ($restype == 2 || $restype == 1) { return true; } return false; } public function isRedirect() { $restype = floor($this->code / 100); if ($restype == 3) { return true; } return false; } public function getBody() { $body = ''; switch (strtolower($this->getHeader('transfer-encoding'))) { case 'chunked': $body = self::decodeChunkedBody($this->body); break; default: $body = $this->body; break; } switch (strtolower($this->getHeader('content-encoding'))) { case 'gzip': $body = self::decodeGzip($body); break; case 'deflate': $body = self::decodeDeflate($body); break; default: break; } return $body; } public function getRawBody() { return $this->body; } public function getVersion() { return $this->version; } public function getStatus() { return $this->code; } public function getMessage() { return $this->message; } public function getHeaders() { return $this->headers; } public function getHeader($header) { $header = ucwords(strtolower($header)); if (! is_string($header) || ! isset($this->headers[$header])) return null; return $this->headers[$header]; } public function getHeadersAsString($status_line = true, $br = "\n") { $str = ''; if ($status_line) { $str = "HTTP/{$this->version} {$this->code} {$this->message}{$br}"; } foreach ($this->headers as $name => $value) { if (is_string($value)) $str .= "{$name}: {$value}{$br}"; elseif (is_array($value)) { foreach ($value as $subval) { $str .= "{$name}: {$subval}{$br}"; } } } return $str; } public function asString($br = "\n") { return $this->getHeadersAsString(true, $br) . $br . $this->getRawBody(); } public function __toString() { return $this->asString(); } public static function responseCodeAsText($code = null, $http11 = true) { $messages = self::$messages; if (! $http11) $messages[302] = 'Moved Temporarily'; if ($code === null) { return $messages; } elseif (isset($messages[$code])) { return $messages[$code]; } else { return 'Unknown'; } } public static function extractCode($response_str) { preg_match("|^HTTP/[\d\.x]+ (\d+)|", $response_str, $m); if (isset($m[1])) { return (int) $m[1]; } else { return false; } } public static function extractMessage($response_str) { preg_match("|^HTTP/[\d\.x]+ \d+ ([^\r\n]+)|", $response_str, $m); if (isset($m[1])) { return $m[1]; } else { return false; } } public static function extractVersion($response_str) { preg_match("|^HTTP/([\d\.x]+) \d+|", $response_str, $m); if (isset($m[1])) { return $m[1]; } else { return false; } } public static function extractHeaders($response_str) { $headers = array(); $parts = preg_split('|(?:\r?\n){2}|m', $response_str, 2); if (! $parts[0]) return $headers; $lines = explode("\n", $parts[0]); unset($parts); $last_header = null; foreach($lines as $line) { $line = trim($line, "\r\n"); if ($line == "") break; if (preg_match("|^([\w-]+):\s*(.+)|", $line, $m)) { unset($last_header); $h_name = strtolower($m[1]); $h_value = $m[2]; if (isset($headers[$h_name])) { if (! is_array($headers[$h_name])) { $headers[$h_name] = array($headers[$h_name]); } $headers[$h_name][] = $h_value; } else { $headers[$h_name] = $h_value; } $last_header = $h_name; } elseif (preg_match("|^\s+(.+)$|", $line, $m) && $last_header !== null) { if (is_array($headers[$last_header])) { end($headers[$last_header]); $last_header_key = key($headers[$last_header]); $headers[$last_header][$last_header_key] .= $m[1]; } else { $headers[$last_header] .= $m[1]; } } } return $headers; } public static function extractBody($response_str) { $parts = preg_split('|(?:\r?\n){2}|m', $response_str, 2); if (isset($parts[1])) { return $parts[1]; } return ''; } public static function decodeChunkedBody($body) { $decBody = ''; if (function_exists('mb_internal_encoding') && ((int) ini_get('mbstring.func_overload')) & 2) { $mbIntEnc = mb_internal_encoding(); mb_internal_encoding('ASCII'); } while (trim($body)) { if (! preg_match("/^([\da-fA-F]+)[^\r\n]*\r\n/sm", $body, $m)) { throw new Exception\RuntimeException("Error parsing body - doesn't seem to be a chunked message"); } $length = hexdec(trim($m[1])); $cut = strlen($m[0]); $decBody .= substr($body, $cut, $length); $body = substr($body, $cut + $length + 2); } if (isset($mbIntEnc)) { mb_internal_encoding($mbIntEnc); } return $decBody; } public static function decodeGzip($body) { if (! function_exists('gzinflate')) { throw new Exception\RuntimeException( 'zlib extension is required in order to decode "gzip" encoding' ); } return gzinflate(substr($body, 10)); } public static function decodeDeflate($body) { if (! function_exists('gzuncompress')) { throw new Exception\RuntimeException( 'zlib extension is required in order to decode "deflate" encoding' ); } $zlibHeader = unpack('n', substr($body, 0, 2)); if ($zlibHeader[1] % 31 == 0) { return gzuncompress($body); } else { return gzinflate($body); } } public static function fromString($response_str) { $code = self::extractCode($response_str); $headers = self::extractHeaders($response_str); $body = self::extractBody($response_str); $version = self::extractVersion($response_str); $message = self::extractMessage($response_str); return new Response($code, $headers, $body, $version, $message); } } 